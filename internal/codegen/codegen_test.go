// SPDX-License-Identifier: MIT

package codegen_test

import (
	"encoding/json"
	"flag"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"testing"

	"github.com/albertocavalcante/lspls/internal/codegen"
	"github.com/albertocavalcante/lspls/internal/model"
	"github.com/albertocavalcante/lspls/internal/testutil"
	"golang.org/x/tools/txtar"
)

var update = flag.Bool("update", false, "update golden files")

func TestCodegen(t *testing.T) {
	testdataDir := filepath.Join("testdata")

	pattern := filepath.Join(testdataDir, "*.txtar")
	files, err := filepath.Glob(pattern)
	if err != nil {
		t.Fatalf("glob %q: %v", pattern, err)
	}

	if len(files) == 0 {
		t.Fatalf("no txtar files found in %q", testdataDir)
	}

	for _, file := range files {
		name := strings.TrimSuffix(filepath.Base(file), ".txtar")
		t.Run(name, func(t *testing.T) {
			ar, err := txtar.ParseFile(file)
			if err != nil {
				t.Fatalf("parse txtar: %v", err)
			}

			tc, err := testutil.ParseCase(name, ar)
			if err != nil {
				t.Fatalf("parse case: %v", err)
			}

			generate := func(input []byte, flags []string) (map[string][]byte, error) {
				return runCodegen(input, flags)
			}

			if *update {
				got, err := generate(tc.Input, tc.Flags)
				if err != nil {
					t.Fatalf("generate: %v", err)
				}

				updated := testutil.UpdateArchive(ar, got)
				content := testutil.FormatArchive(updated)

				if err := os.WriteFile(file, content, 0o644); err != nil {
					t.Fatalf("write updated file: %v", err)
				}
				t.Logf("updated %s", file)
				return
			}

			tc.Run(t, generate)
		})
	}
}

// runCodegen generates code from input JSON and returns the output files.
func runCodegen(input []byte, flags []string) (map[string][]byte, error) {
	// Parse the model
	var m model.Model
	if err := json.Unmarshal(input, &m); err != nil {
		return nil, err
	}

	// Configure code generation
	cfg := codegen.Config{
		PackageName:     "protocol",
		ResolveDeps:     true, // Default to true to match CLI behavior
		IncludeProposed: slices.Contains(flags, "proposed"),
		GenerateServer:  slices.Contains(flags, "server"),
		GenerateClient:  slices.Contains(flags, "client"),
	}

	// Parse type filter from flags
	for _, f := range flags {
		if typeList, ok := strings.CutPrefix(f, "types="); ok {
			cfg.Types = strings.Split(typeList, ",")
		}
		if pkgName, ok := strings.CutPrefix(f, "package="); ok {
			cfg.PackageName = pkgName
		}
		if f == "no-resolve-deps" {
			cfg.ResolveDeps = false
		}
	}

	// Generate
	gen := codegen.New(&m, cfg)
	out, err := gen.Generate()
	if err != nil {
		return nil, err
	}

	result := make(map[string][]byte)

	// Strip variable header info for comparison
	// The header contains Source, Ref, Commit, LSP Version which vary
	protocol := stripGeneratedHeader(out.Protocol)
	result["protocol.go"] = protocol

	return result, nil
}

// stripGeneratedHeader removes the variable parts of the generated header,
// keeping only "// Code generated by lspls. DO NOT EDIT." and package declaration.
func stripGeneratedHeader(content []byte) []byte {
	lines := strings.Split(string(content), "\n")
	var result []string
	inHeader := true

	for _, line := range lines {
		// Keep the "Code generated" line
		if strings.HasPrefix(line, "// Code generated by lspls") {
			result = append(result, line)
			continue
		}
		// Skip other header comments (Source, Ref, Commit, LSP Version) only while in header
		if inHeader && strings.HasPrefix(line, "// ") {
			continue
		}
		// Once we hit a non-comment line, we're past the header
		if inHeader && !strings.HasPrefix(line, "//") {
			inHeader = false
		}
		// Include everything after we exit the header
		result = append(result, line)
	}

	return []byte(strings.Join(result, "\n"))
}
