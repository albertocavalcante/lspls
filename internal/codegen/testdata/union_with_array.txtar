Test union type containing an array type (e.g., Location | []Location).
The generated Or_* type name must be a valid Go identifier - []Location becomes ArrLocation.

-- input.json --
{
  "metaData": {"version": "3.17.0"},
  "structures": [
    {
      "name": "Location",
      "properties": [
        {"name": "uri", "type": {"kind": "base", "name": "string"}}
      ]
    }
  ],
  "enumerations": [],
  "typeAliases": [
    {
      "name": "Declaration",
      "type": {
        "kind": "or",
        "items": [
          {"kind": "reference", "name": "Location"},
          {"kind": "array", "element": {"kind": "reference", "name": "Location"}}
        ]
      }
    }
  ]
}

-- want/protocol.go --
// Code generated by lspls. DO NOT EDIT.
package protocol

import (
	"encoding/json"
	"fmt"
)

type Declaration = Or_ArrLocation_Location

type Location struct {
	Uri string `json:"uri"`
}

// Or_ArrLocation_Location is a union type for: []Location | Location
type Or_ArrLocation_Location struct {
	Value any `json:"value"`
}

func (t Or_ArrLocation_Location) MarshalJSON() ([]byte, error) {
	switch x := t.Value.(type) {
	case []Location:
		return json.Marshal(x)
	case Location:
		return json.Marshal(x)
	case nil:
		return []byte("null"), nil
	}
	return nil, fmt.Errorf("type %T not one of [[]Location Location]", t.Value)
}

func (t *Or_ArrLocation_Location) UnmarshalJSON(x []byte) error {
	if string(x) == "null" {
		t.Value = nil
		return nil
	}
	var h0 []Location
	if err := json.Unmarshal(x, &h0); err == nil {
		t.Value = h0
		return nil
	}
	var h1 Location
	if err := json.Unmarshal(x, &h1); err == nil {
		t.Value = h1
		return nil
	}
	return fmt.Errorf("unmarshal failed to match one of [[]Location Location]")
}
