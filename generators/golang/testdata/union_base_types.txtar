Test union type generation with base types (string, int32, etc.).
Union types with base types should also generate proper Or_* types.

-- input.json --
{
  "metaData": {"version": "3.17.0"},
  "structures": [
    {
      "name": "ProgressParams",
      "documentation": "Parameters for progress notification.",
      "properties": [
        {
          "name": "token",
          "type": {
            "kind": "or",
            "items": [
              {"kind": "base", "name": "integer"},
              {"kind": "base", "name": "string"}
            ]
          },
          "documentation": "The progress token provided by the client or server."
        },
        {
          "name": "value",
          "type": {"kind": "base", "name": "LSPAny"},
          "documentation": "The progress data."
        }
      ]
    }
  ],
  "enumerations": [],
  "typeAliases": []
}

-- want/protocol.go --
// Code generated by lspls. DO NOT EDIT.
package protocol

import (
	"encoding/json"
	"fmt"
)

// Parameters for progress notification.
type ProgressParams struct {
	// The progress token provided by the client or server.
	Token Or_int32_string `json:"token"`
	// The progress data.
	Value any `json:"value"`
}

// Or_int32_string is a union type for: int32 | string
type Or_int32_string struct {
	Value any `json:"value"`
}

func (t Or_int32_string) MarshalJSON() ([]byte, error) {
	switch x := t.Value.(type) {
	case int32:
		return json.Marshal(x)
	case string:
		return json.Marshal(x)
	case nil:
		return []byte("null"), nil
	}
	return nil, fmt.Errorf("type %T not one of [int32 string]", t.Value)
}

func (t *Or_int32_string) UnmarshalJSON(x []byte) error {
	if string(x) == "null" {
		t.Value = nil
		return nil
	}
	var h0 int32
	if err := json.Unmarshal(x, &h0); err == nil {
		t.Value = h0
		return nil
	}
	var h1 string
	if err := json.Unmarshal(x, &h1); err == nil {
		t.Value = h1
		return nil
	}
	return fmt.Errorf("unmarshal failed to match one of [int32 string]")
}
