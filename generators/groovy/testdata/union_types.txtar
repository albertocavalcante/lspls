Test union type generation with wrapper class and Jackson deserializer.

-- input.json --
{
  "metaData": {"version": "3.17.0"},
  "structures": [
    {
      "name": "TextEdit",
      "documentation": "A text edit.",
      "properties": [
        {
          "name": "newText",
          "type": {"kind": "base", "name": "string"},
          "documentation": "The new text."
        }
      ]
    },
    {
      "name": "AnnotatedTextEdit",
      "documentation": "An annotated text edit.",
      "properties": [
        {
          "name": "newText",
          "type": {"kind": "base", "name": "string"},
          "documentation": "The new text."
        },
        {
          "name": "annotationId",
          "type": {"kind": "base", "name": "string"},
          "documentation": "The annotation ID."
        }
      ]
    },
    {
      "name": "TextDocumentEdit",
      "documentation": "Describes textual changes on a text document.",
      "properties": [
        {
          "name": "edits",
          "type": {
            "kind": "array",
            "element": {
              "kind": "or",
              "items": [
                {"kind": "reference", "name": "TextEdit"},
                {"kind": "reference", "name": "AnnotatedTextEdit"}
              ]
            }
          },
          "documentation": "The edits to be applied."
        }
      ]
    }
  ],
  "enumerations": [],
  "typeAliases": []
}

-- want/Protocol.groovy --
// Code generated by lspls. DO NOT EDIT.
package lsp.protocol

import com.fasterxml.jackson.annotation.JsonIgnoreProperties
import com.fasterxml.jackson.annotation.JsonValue
import com.fasterxml.jackson.core.JsonParser
import com.fasterxml.jackson.databind.DeserializationContext
import com.fasterxml.jackson.databind.JsonDeserializer
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import groovy.transform.CompileStatic

/**
 * An annotated text edit.
 */
@CompileStatic
@JsonIgnoreProperties(ignoreUnknown = true)
record AnnotatedTextEdit(
    /** The new text. */
    String newText,
    /** The annotation ID. */
    String annotationId
) {}

/**
 * Describes textual changes on a text document.
 */
@CompileStatic
@JsonIgnoreProperties(ignoreUnknown = true)
record TextDocumentEdit(
    /** The edits to be applied. */
    List<Or_AnnotatedTextEdit_TextEdit> edits
) {}

/**
 * A text edit.
 */
@CompileStatic
@JsonIgnoreProperties(ignoreUnknown = true)
record TextEdit(
    /** The new text. */
    String newText
) {}

/**
 * Union type: AnnotatedTextEdit | TextEdit
 */
@CompileStatic
@JsonDeserialize(using = Or_AnnotatedTextEdit_TextEditDeserializer)
sealed class Or_AnnotatedTextEdit_TextEdit {
    final Object value
    protected Or_AnnotatedTextEdit_TextEdit(Object value) { this.value = value }
    @JsonValue
    Object getValue() { value }

    static final class AnnotatedTextEditValue extends Or_AnnotatedTextEdit_TextEdit {
        AnnotatedTextEditValue(AnnotatedTextEdit value) { super(value) }
    }
    static final class TextEditValue extends Or_AnnotatedTextEdit_TextEdit {
        TextEditValue(TextEdit value) { super(value) }
    }
}

@CompileStatic
class Or_AnnotatedTextEdit_TextEditDeserializer extends JsonDeserializer<Or_AnnotatedTextEdit_TextEdit> {
    @Override
    Or_AnnotatedTextEdit_TextEdit deserialize(JsonParser p, DeserializationContext ctxt) {
        JsonNode node = p.readValueAsTree()
        if (node.isObject()) {
            try {
                return new Or_AnnotatedTextEdit_TextEdit.AnnotatedTextEditValue(p.codec.treeToValue(node, AnnotatedTextEdit))
            } catch (Exception ignored) {}
        }
        if (node.isObject()) {
            try {
                return new Or_AnnotatedTextEdit_TextEdit.TextEditValue(p.codec.treeToValue(node, TextEdit))
            } catch (Exception ignored) {}
        }
        throw ctxt.weirdStringException(node.toString(), Or_AnnotatedTextEdit_TextEdit, 'Expected AnnotatedTextEdit or TextEdit')
    }
}
