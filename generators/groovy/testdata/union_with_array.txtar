Test union type containing an array type (e.g., Location | List<Location>).

-- input.json --
{
  "metaData": {"version": "3.17.0"},
  "structures": [
    {
      "name": "Location",
      "properties": [
        {"name": "uri", "type": {"kind": "base", "name": "string"}}
      ]
    }
  ],
  "enumerations": [],
  "typeAliases": [
    {
      "name": "Declaration",
      "type": {
        "kind": "or",
        "items": [
          {"kind": "reference", "name": "Location"},
          {"kind": "array", "element": {"kind": "reference", "name": "Location"}}
        ]
      }
    }
  ]
}

-- want/Protocol.groovy --
// Code generated by lspls. DO NOT EDIT.
package lsp.protocol

import com.fasterxml.jackson.annotation.JsonIgnoreProperties
import com.fasterxml.jackson.annotation.JsonValue
import com.fasterxml.jackson.core.JsonParser
import com.fasterxml.jackson.databind.DeserializationContext
import com.fasterxml.jackson.databind.JsonDeserializer
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import groovy.transform.CompileStatic

// Type alias: Declaration = Or_ArrLocation_Location

@CompileStatic
@JsonIgnoreProperties(ignoreUnknown = true)
record Location(
    String uri
) {}

/**
 * Union type: List<Location> | Location
 */
@CompileStatic
@JsonDeserialize(using = Or_ArrLocation_LocationDeserializer)
sealed class Or_ArrLocation_Location {
    final Object value
    protected Or_ArrLocation_Location(Object value) { this.value = value }
    @JsonValue
    Object getValue() { value }

    static final class ArrLocationValue extends Or_ArrLocation_Location {
        ArrLocationValue(List<Location> value) { super(value) }
    }
    static final class LocationValue extends Or_ArrLocation_Location {
        LocationValue(Location value) { super(value) }
    }
}

@CompileStatic
class Or_ArrLocation_LocationDeserializer extends JsonDeserializer<Or_ArrLocation_Location> {
    @Override
    Or_ArrLocation_Location deserialize(JsonParser p, DeserializationContext ctxt) {
        JsonNode node = p.readValueAsTree()
        if (node.isArray()) {
            List<Location> list = []
            node.each { JsonNode item -> list.add(p.codec.treeToValue(item, Location)) }
            return new Or_ArrLocation_Location.ArrLocationValue(list)
        }
        if (node.isObject()) return new Or_ArrLocation_Location.LocationValue(p.codec.treeToValue(node, Location))
        throw ctxt.weirdStringException(node.toString(), Or_ArrLocation_Location, 'Expected List<Location> or Location')
    }
}
