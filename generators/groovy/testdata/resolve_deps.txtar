Test that transitive dependencies are automatically resolved.
Range references Position, so both should be generated when filtering for Range.

Flags: types=Range

-- input.json --
{
  "metaData": {"version": "3.17.0"},
  "structures": [
    {
      "name": "Position",
      "properties": [
        {"name": "line", "type": {"kind": "base", "name": "uinteger"}},
        {"name": "character", "type": {"kind": "base", "name": "uinteger"}}
      ]
    },
    {
      "name": "Range",
      "properties": [
        {"name": "start", "type": {"kind": "reference", "name": "Position"}},
        {"name": "end", "type": {"kind": "reference", "name": "Position"}}
      ]
    },
    {
      "name": "Unrelated",
      "properties": [
        {"name": "value", "type": {"kind": "base", "name": "string"}}
      ]
    }
  ],
  "enumerations": [],
  "typeAliases": []
}

-- want/Protocol.groovy --
// Code generated by lspls. DO NOT EDIT.
package lsp.protocol

import com.fasterxml.jackson.annotation.JsonIgnoreProperties
import groovy.transform.CompileStatic

@CompileStatic
@JsonIgnoreProperties(ignoreUnknown = true)
record Position(
    int line,
    int character
) {}

@CompileStatic
@JsonIgnoreProperties(ignoreUnknown = true)
record Range(
    Position start,
    Position end
) {}

