// SPDX-License-Identifier: MIT
//
// Copyright 2026 Alberto Cavalcante. All rights reserved.
// Use of this source code is governed by a MIT-style license
// that can be found in the LICENSE file.

// Package proto generates Protocol Buffer definitions from the LSP specification.
package proto

import (
	"fmt"
	"strings"
	"unicode"

	"github.com/albertocavalcante/lspls/model"
)

// Config holds configuration for proto generation.
type Config struct {
	// PackageName is the proto package name (e.g., "lsp").
	PackageName string

	// GoPackage is the go_package option value.
	GoPackage string

	// Types to include (empty means all).
	Types []string

	// ResolveDeps includes transitively referenced types.
	ResolveDeps bool

	// IncludeProposed generates types marked as proposed.
	IncludeProposed bool

	// Source metadata for header comments.
	Source     string
	Ref        string
	CommitHash string
	LSPVersion string
}

// Codegen generates proto3 definitions from the LSP model.
type Codegen struct {
	model  *model.Model
	config Config
}

// New creates a new proto Codegen.
func New(m *model.Model, cfg Config) *Codegen {
	return &Codegen{
		model:  m,
		config: cfg,
	}
}

// Output contains the generated proto content.
type Output struct {
	Proto []byte
}

// Generate produces the proto3 definitions.
func (g *Codegen) Generate() (*Output, error) {
	var b strings.Builder

	// Header
	b.WriteString(g.generateHeader())  
	b.WriteString("\n")

	// Package declaration
	b.WriteString(fmt.Sprintf("package %s;\n\n", g.config.PackageName))

	// Go package option
	if g.config.GoPackage != "" {
		b.WriteString(fmt.Sprintf("option go_package = %q;\n\n", g.config.GoPackage))
	}

	// Generate enums first (dependencies)
	for _, enum := range g.model.Enumerations {
		if !g.config.IncludeProposed && enum.Proposed {
			continue
		}
		b.WriteString(g.generateEnum(enum))
		b.WriteString("\n")
	}

	// Generate messages
	for _, structure := range g.model.Structures {
		if !g.config.IncludeProposed && structure.Proposed {
			continue
		}
		b.WriteString(g.generateMessage(structure))
		b.WriteString("\n")
	}

	return &Output{Proto: []byte(b.String())}, nil
}

func (g *Codegen) generateHeader() string {
	var b strings.Builder
	b.WriteString("// Code generated by lspls. DO NOT EDIT.\n")
	if g.config.Source != "" {
		b.WriteString(fmt.Sprintf("// Source: %s\n", g.config.Source))
	}
	if g.config.Ref != "" {
		b.WriteString(fmt.Sprintf("// Ref: %s\n", g.config.Ref))
	}
	if g.config.CommitHash != "" {
		b.WriteString(fmt.Sprintf("// Commit: %s\n", g.config.CommitHash))
	}
	if g.config.LSPVersion != "" {
		b.WriteString(fmt.Sprintf("// LSP Version: %s\n", g.config.LSPVersion))
	}
	b.WriteString("\nsyntax = \"proto3\";\n")
	return b.String()
}

func (g *Codegen) generateMessage(s *model.Structure) string {
	var b strings.Builder

	// Documentation
	if s.Documentation != "" {
		for _, line := range strings.Split(s.Documentation, "\n") {
			b.WriteString(fmt.Sprintf("// %s\n", line))
		}
	}

	b.WriteString(fmt.Sprintf("message %s {\n", toProtoMessageName(s.Name)))

	fieldNum := 1
	for _, prop := range s.Properties {
		protoType, err := g.convertType(prop.Type)
		if err != nil {
			// Skip fields we can't convert
			b.WriteString(fmt.Sprintf("  // %s: skipped (%s)\n", prop.Name, err))
			continue
		}

		fieldName := toProtoFieldName(prop.Name)

		// Add field documentation (all lines)
		if prop.Documentation != "" {
			for _, line := range strings.Split(prop.Documentation, "\n") {
				b.WriteString(fmt.Sprintf("  // %s\n", line))
			}
		}

		// Optional fields
		if prop.Optional {
			b.WriteString(fmt.Sprintf("  optional %s %s = %d;\n", protoType, fieldName, fieldNum))
		} else {
			b.WriteString(fmt.Sprintf("  %s %s = %d;\n", protoType, fieldName, fieldNum))
		}
		fieldNum++
	}

	b.WriteString("}\n")
	return b.String()
}

func (g *Codegen) generateEnum(e *model.Enumeration) string {
	var b strings.Builder

	// Documentation
	if e.Documentation != "" {
		for _, line := range strings.Split(e.Documentation, "\n") {
			b.WriteString(fmt.Sprintf("// %s\n", line))
		}
	}

	enumName := toProtoMessageName(e.Name)
	b.WriteString(fmt.Sprintf("enum %s {\n", enumName))

	// Proto3 requires first value to be 0
	prefix := toEnumPrefix(e.Name)
	b.WriteString(fmt.Sprintf("  %s_UNSPECIFIED = 0;\n", prefix))

	// Track next sequential value for string enums
	nextSeqValue := 1

	for _, v := range e.Values {
		valueName := toEnumValueName(prefix, v.Name)

		// Get the numeric value
		var numValue int
		switch val := v.Value.(type) {
		case float64:
			numValue = int(val)
		case int:
			numValue = val
		case string:
			// String enums - assign sequential numbers
			numValue = nextSeqValue
			nextSeqValue++
		default:
			// Unknown type - skip
			continue
		}

		if v.Documentation != "" {
			b.WriteString(fmt.Sprintf("  // %s\n", strings.Split(v.Documentation, "\n")[0]))
		}
		b.WriteString(fmt.Sprintf("  %s = %d;\n", valueName, numValue))
	}

	b.WriteString("}\n")
	return b.String()
}

func (g *Codegen) convertType(t *model.Type) (string, error) {
	if t == nil {
		return "", fmt.Errorf("nil type")
	}

	switch t.Kind {
	case "base":
		return convertBaseType(t.Name)

	case "reference":
		return toProtoMessageName(t.Name), nil

	case "array":
		elemType, err := g.convertType(t.Element)
		if err != nil {
			return "", err
		}
		return "repeated " + elemType, nil

	case "map":
		keyType, err := g.convertType(t.Key)
		if err != nil {
			return "", err
		}
		valType, ok := t.Value.(*model.Type)
		if !ok {
			return "", fmt.Errorf("map value is not a type")
		}
		valTypeStr, err := g.convertType(valType)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("map<%s, %s>", keyType, valTypeStr), nil

	case "or":
		// Union types - for now, use google.protobuf.Any or first non-null type
		for _, item := range t.Items {
			if item.Kind != "base" || item.Name != "null" {
				return g.convertType(item)
			}
		}
		return "", fmt.Errorf("union with only null types")

	case "literal":
		// Inline struct - would need nested message
		return "", fmt.Errorf("literal types require nested messages")

	case "stringLiteral":
		return "string", nil

	case "tuple":
		return "", fmt.Errorf("tuples not directly supported in proto3")

	default:
		return "", fmt.Errorf("unknown type kind: %s", t.Kind)
	}
}

// convertBaseType converts an LSP base type to a proto3 type.
func convertBaseType(name string) (string, error) {
	switch name {
	case "string", "DocumentUri", "URI":
		return "string", nil
	case "integer":
		return "int32", nil
	case "uinteger":
		return "uint32", nil
	case "decimal":
		return "double", nil
	case "boolean":
		return "bool", nil
	case "null":
		return "", fmt.Errorf("null type cannot be represented in proto3")
	default:
		return "", fmt.Errorf("unknown base type: %s", name)
	}
}

// toProtoMessageName converts an LSP type name to a proto message name.
func toProtoMessageName(name string) string {
	// Strip leading $ if present
	name = strings.TrimPrefix(name, "$")
	if name == "" {
		return name
	}
	// Ensure first letter is uppercase
	return string(unicode.ToUpper(rune(name[0]))) + name[1:]
}

// toProtoFieldName converts an LSP field name to a proto field name (snake_case).
func toProtoFieldName(name string) string {
	// Check if entire name is uppercase (like URI, ID)
	allUpper := true
	for _, r := range name {
		if !unicode.IsUpper(r) && unicode.IsLetter(r) {
			allUpper = false
			break
		}
	}
	if allUpper {
		return strings.ToLower(name)
	}

	var result strings.Builder
	for i, r := range name {
		if unicode.IsUpper(r) {
			if i > 0 {
				result.WriteRune('_')
			}
			result.WriteRune(unicode.ToLower(r))
		} else {
			result.WriteRune(r)
		}
	}
	return result.String()
}

// toEnumPrefix converts an enum name to a SCREAMING_SNAKE_CASE prefix.
func toEnumPrefix(name string) string {
	var result strings.Builder
	for i, r := range name {
		if unicode.IsUpper(r) && i > 0 {
			result.WriteRune('_')
		}
		result.WriteRune(unicode.ToUpper(r))
	}
	return result.String()
}

// toEnumValueName creates a proto enum value name.
func toEnumValueName(prefix, name string) string {
	valuePart := toEnumPrefix(name)
	return prefix + "_" + valuePart
}
