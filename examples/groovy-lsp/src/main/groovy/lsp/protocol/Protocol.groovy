// Code generated by lspls. DO NOT EDIT.
// Source: https://github.com/microsoft/vscode-languageserver-node@release/protocol/3.17.6-next.14
// Ref: release/protocol/3.17.6-next.14
// Commit: 66a087310eea0d60495ba3578d78f70409c403d9
// LSP Version: 3.17.0
package lsp.protocol

import com.fasterxml.jackson.annotation.JsonCreator
import com.fasterxml.jackson.annotation.JsonIgnoreProperties
import com.fasterxml.jackson.annotation.JsonValue
import groovy.transform.CompileStatic

/**
 * The diagnostic's severity.
 */
@CompileStatic
enum DiagnosticSeverity {
    /**
     * Reports an error.
     */
    ERROR(1),
    /**
     * Reports a warning.
     */
    WARNING(2),
    /**
     * Reports an information.
     */
    INFORMATION(3),
    /**
     * Reports a hint.
     */
    HINT(4)

    final int value
    DiagnosticSeverity(int value) { this.value = value }
    @JsonValue
    int getValue() { value }
    @JsonCreator
    static DiagnosticSeverity fromValue(int value) {
        values().find { it.value == value }
    }
}

/**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 * 
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */
@CompileStatic
enum MarkupKind {
    /**
     * Plain text is supported as a content format
     */
    PLAIN_TEXT('plaintext'),
    /**
     * Markdown is supported as a content format
     */
    MARKDOWN('markdown')

    final String value
    MarkupKind(String value) { this.value = value }
    @JsonValue
    String getValue() { value }
}

/**
 * Position in a text document expressed as zero-based line and character
 * offset. Prior to 3.17 the offsets were always based on a UTF-16 string
 * representation. So a string of the form `aêêÄb` the character offset of the
 * character `a` is 0, the character offset of `êêÄ` is 1 and the character
 * offset of b is 3 since `êêÄ` is represented using two code units in UTF-16.
 * Since 3.17 clients and servers can agree on a different string encoding
 * representation (e.g. UTF-8). The client announces it's supported encoding
 * via the client capability [`general.positionEncodings`](https://microsoft.github.io/language-server-protocol/specifications/specification-current/#clientCapabilities).
 * The value is an array of position encodings the client supports, with
 * decreasing preference (e.g. the encoding at index `0` is the most preferred
 * one). To stay backwards compatible the only mandatory encoding is UTF-16
 * represented via the string `utf-16`. The server can pick one of the
 * encodings offered by the client and signals that encoding back to the
 * client via the initialize result's property
 * [`capabilities.positionEncoding`](https://microsoft.github.io/language-server-protocol/specifications/specification-current/#serverCapabilities). If the string value
 * `utf-16` is missing from the client's capability `general.positionEncodings`
 * servers can safely assume that the client supports UTF-16. If the server
 * omits the position encoding in its initialize result the encoding defaults
 * to the string value `utf-16`. Implementation considerations: since the
 * conversion from one encoding into another requires the content of the
 * file / line the conversion is best done where the file is read which is
 * usually on the server side.
 * 
 * Positions are line end character agnostic. So you can not specify a position
 * that denotes `\r|\n` or `\n|` where `|` represents the character offset.
 * 
 * @since 3.17.0 - support for negotiated position encoding.
 */
@CompileStatic
@JsonIgnoreProperties(ignoreUnknown = true)
record Position(
    /** Line position in a document (zero-based). */
    int line,
    /** Character offset on a line in a document (zero-based). */
    /**  */
    /** The meaning of this offset is determined by the negotiated */
    /** `PositionEncodingKind`. */
    int character
) {}

/**
 * A range in a text document expressed as (zero-based) start and end positions.
 * 
 * If you want to specify a range that contains a line including the line ending
 * character(s) then use an end position denoting the start of the next line.
 * For example:
 * ```ts
 * {
 *     start: { line: 5, character: 23 }
 *     end : { line 6, character : 0 }
 * }
 * ```
 */
@CompileStatic
@JsonIgnoreProperties(ignoreUnknown = true)
record Range(
    /** The range's start position. */
    Position start,
    /** The range's end position. */
    Position end
) {}

/**
 * A literal to identify a text document in the client.
 */
@CompileStatic
@JsonIgnoreProperties(ignoreUnknown = true)
record TextDocumentIdentifier(
    /** The text document's uri. */
    String uri
) {}

/**
 * A text edit applicable to a text document.
 */
@CompileStatic
@JsonIgnoreProperties(ignoreUnknown = true)
record TextEdit(
    /** The range of the text document to be manipulated. To insert */
    /** text into a document create a range where start === end. */
    Range range,
    /** The string to be inserted. For delete operations use an */
    /** empty string. */
    String newText
) {}

